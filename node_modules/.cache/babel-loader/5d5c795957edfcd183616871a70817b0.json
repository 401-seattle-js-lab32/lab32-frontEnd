{"ast":null,"code":"'use strict';\n\nvar _classCallCheck = require(\"/Users/coreymarchand/Desktop/codeFellows/401/assignments/lab32/lab32-frontEnd/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/Users/coreymarchand/Desktop/codeFellows/401/assignments/lab32/lab32-frontEnd/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nvar io = require('socket.io-client');\n\nvar SERVER = process.env.Q_SERVER || process.env.REACT_APP_Q_SERVER || 'http://localhost:3333';\n/** Class representing a subscriber instance to the Queue. */\n\nvar Q =\n/*#__PURE__*/\nfunction () {\n  function Q(q) {\n    _classCallCheck(this, Q);\n\n    this.q = q; // a \"namespace\" in the Queue Server\n\n    this.sockets = [];\n  }\n  /**\n   * This function helps us subscribe\n   * @param event {string} - indicating the event name (socket.io room in actuality)\n   * @param callback {function} - Callback to execute on hearing the subscribed event\n   */\n\n\n  _createClass(Q, [{\n    key: \"subscribe\",\n    value: function subscribe(event, callback) {\n      // event is technically a socket.io room managed by the Queue Server\n      console.log(\"connect to: \".concat(SERVER, \"/\").concat(this.q));\n      this.sockets[event] = io.connect(\"\".concat(SERVER, \"/\").concat(this.q));\n      this.sockets[event].emit('subscribe', event, function (err, status) {\n        if (err) {\n          console.error(err);\n        } else {\n          console.log(status);\n        }\n      });\n      this.sockets[event].on('trigger', callback);\n    }\n    /**\n     * What queues am I connected to?\n     * @returns {string[]}\n     */\n\n  }, {\n    key: \"subscriptions\",\n    value: function subscriptions() {\n      return Object.keys(this.sockets);\n    }\n    /**\n     * TODO\n     * Unsubscribe from an event\n     * @param event\n     */\n\n  }, {\n    key: \"unsubscribe\",\n    value: function unsubscribe(event) {}\n    /**\n     * TODO\n     * Completely disconnect from a queue (which will inherently unsubscribe from all events)\n     */\n\n  }, {\n    key: \"disconnect\",\n    value: function disconnect() {}\n    /**\n     * Static method to publish an event (room) with payload\n     * Why static?  Publishers don't need to maintain a connection to an event queue. They are short-lived\n     * This client library provides a simple means to quickly connect, publish a named event to a queue and then disconnect\n     * @param queue\n     * @param event\n     * @param payload\n     */\n\n  }], [{\n    key: \"publish\",\n    value: function publish(queue, event, payload) {\n      var q = io.connect(\"\".concat(SERVER));\n      var message = {\n        queue: queue,\n        event: event,\n        payload: payload\n      };\n      q.emit('publish', message, function (ret) {\n        q.disconnect();\n      });\n    }\n  }]);\n\n  return Q;\n}();\n\nmodule.exports = Q;","map":null,"metadata":{},"sourceType":"script"}